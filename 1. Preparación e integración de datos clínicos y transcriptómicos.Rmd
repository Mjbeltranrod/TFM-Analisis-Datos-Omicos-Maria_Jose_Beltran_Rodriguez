---
title: "Procesamiento y armonización de cohortes seleccionadas. Creación de cohorte global integrada y su análisis descriptivo."
author: "María José Beltrán Rodríguez"
date: "2025-10-21"
output: html_document
---

```{r libreria, message=FALSE, warning=FALSE, include=FALSE}
# renv::init()
# Para restablecer todos los paquetes y sus versiones ejecuta el siguiente comando.
# renv::restore()

library(GEOquery)
options(timeout = 600)
library(readr)
library(dplyr)
library(tidyr)
library(kableExtra)
library(summarytools)
library(stringr)
library(patchwork)

library(affy)
library(oligo)
library(arrayQualityMetrics)
library(limma)
library(sva)
library(hgu133plus2.db)
library(ggplot2)
library(AnnotationDbi)
library(RColorBrewer)

```

## Preparación de datos clínicos y técnicos 
En la preparación de datos se siguió un procedimiento común para todas las cohortes. Este incluía la selección de columnas de interés, seguido de su armonización y un filtrado de pacientes eliminando a los que no tienen información sobre seguimiento ni estadio del tumor.  A pesar de que el procedimiento es común el código no se pudo estandarizar debido a que el formato de datos de cada cohorte era diferente. 


### GSE39582
```{r GSE39582, echo=FALSE, message=FALSE, warning=FALSE}
## Procesamiento y armonización de datos clínicos

# Carga de datos
gse39582 <- getGEO("GSE39582", GSEMatrix = TRUE)
datos39582 <- gse39582[["GSE39582_series_matrix.txt.gz"]]@phenoData@data

## Selección de columnas de interés
datos39582_clean <- datos39582[, c(
  "geo_accession",
  "age.at.diagnosis (year):ch1",
  "Sex:ch1",
  "tnm.stage:ch1",
  "tumor.location:ch1",
  "mmr.status:ch1",
  "chemotherapy.adjuvant:ch1",
  "chemotherapy.adjuvant.type:ch1",
  "rfs.delay:ch1",
  "rfs.event:ch1",
  "os.delay (months):ch1",
  "os.event:ch1",
  "platform_id",
  "rna.extraction.method:ch1",
  "data_processing"
)]

# Renombramiento de columnas para ajustarlas al dataframe final
colnames(datos39582_clean) <- c(
  "SampleID",
  "Age",
  "Gender",
  "Stage",
  "Tumor_Location",
  "MSI_Status",
  "Treatment_Adjuvant",
  "Treatment_Adjuvant_type",
  "DFS_time",
  "DFS_Event",
  "OS_time",
  "OS_Event",
  "Platform",
  "RNA_Extraction",
  "Normalization_Method"
)

# Creación la columna "Cohorte"
datos39582_clean$Cohorte <- "GSE39582"
datos39582_clean$Batch <- 1


## Armonización de variables
numeric_vars <- c("Age", "DFS_time", "OS_time")
datos39582_clean[numeric_vars] <- lapply(datos39582_clean[numeric_vars], as.numeric)

# Gender
datos39582_clean$Gender <- tolower(datos39582_clean$Gender)
datos39582_clean$Gender <- ifelse(datos39582_clean$Gender %in% c("male", "m"), "Male",
                           ifelse(datos39582_clean$Gender %in% c("female", "f"), "Female", NA))
datos39582_clean$Gender <- factor(datos39582_clean$Gender, levels = c("Male", "Female"))

# Stage 
datos39582_clean$Stage <- dplyr::recode(datos39582_clean$Stage,
  "1" = "I",
  "2" = "II",
  "3" = "III",
  "4" = "IV",
  .default = "UK"
)
datos39582_clean$Stage <- factor(datos39582_clean$Stage, levels = c("I","II","III","IV","UK"))


# Tumor location
datos39582_clean$Tumor_Location <- tolower(datos39582_clean$Tumor_Location)
datos39582_clean$Tumor_Location <- ifelse(datos39582_clean$Tumor_Location %in% c("distal","proximal"),
                                          datos39582_clean$Tumor_Location, "UK")
datos39582_clean$Tumor_Location <- factor(datos39582_clean$Tumor_Location,
                                          levels = c("distal","proximal","UK"))

# MSI/MMR status
datos39582_clean$MSI_Status <- toupper(datos39582_clean$MSI_Status)
datos39582_clean$MSI_Status <- ifelse(datos39582_clean$MSI_Status %in% c("PMMR","MSS"), "MSS",
                               ifelse(datos39582_clean$MSI_Status %in% c("DMMR","MSI"), "MSI", "UK"))
datos39582_clean$MSI_Status <- factor(datos39582_clean$MSI_Status, levels = c("MSS","MSI","UK"))

# Adjuvant treatment
datos39582_clean$Treatment_Adjuvant <- toupper(datos39582_clean$Treatment_Adjuvant)
datos39582_clean$Treatment_Adjuvant <- ifelse(datos39582_clean$Treatment_Adjuvant == "Y", "Yes",
                                       ifelse(datos39582_clean$Treatment_Adjuvant == "N", "No", "No"))
datos39582_clean$Treatment_Adjuvant <- factor(datos39582_clean$Treatment_Adjuvant, levels = c("Yes","No"))

# DFS/OS events
datos39582_clean$DFS_Event <- ifelse(datos39582_clean$DFS_Event == "1", "Yes",
                              ifelse(datos39582_clean$DFS_Event == "0", "No", NA))
datos39582_clean$OS_Event  <- ifelse(datos39582_clean$OS_Event == "1", "Yes",
                              ifelse(datos39582_clean$OS_Event == "0", "No", NA))
datos39582_clean$DFS_Event <- factor(datos39582_clean$DFS_Event, levels = c("Yes","No"))
datos39582_clean$OS_Event  <- factor(datos39582_clean$OS_Event, levels = c("Yes","No"))

# Campos técnicos sin información explícita
datos39582_clean$Percent_Tumor <- ">= 70%"
datos39582_clean$RIN <- ">= 7"

## Filtrado de pacientes 
datos39582_clean <- datos39582_clean[
  (
    # Tiene al menos un dato en DFS (tiempo o evento)
    (!is.na(datos39582_clean$DFS_time) | !is.na(datos39582_clean$DFS_Event)) |
    # O tiene al menos un dato en OS (tiempo o evento)
    (!is.na(datos39582_clean$OS_time) | !is.na(datos39582_clean$OS_Event))
  ) &
  # Y tiene Stage definido (no NA, ni "UK", ni vacío)
  !is.na(datos39582_clean$Stage) &
  datos39582_clean$Stage != "UK" &
  datos39582_clean$Stage != "",
]

## Summary
 st_options(dfSummary.graph.col = TRUE,  
           dfSummary.graph.magnif = 1.2)  
 print(dfSummary(datos39582_clean), method = "render", escape = FALSE)

```

```{r GSE39582 exp, echo=FALSE, message=FALSE, warning=FALSE}
## Matriz de expresión génica ya normalizada proporcionada por el estudio
exp_matrix39582 <- gse39582[["GSE39582_series_matrix.txt.gz"]]@assayData[["exprs"]]

# Selección de las columnas coincidentes y en el mismo orden que en los datos clínicos ya procesados
exp_matrix39582 <- exp_matrix39582[, datos39582_clean$SampleID]
all(colnames(exp_matrix39582) == datos39582_clean$SampleID)

save(exp_matrix39582, file = "Expresión RMA sin anotar GSE39582.RData")

```


### GSE17536
```{r GSE17536, echo=FALSE, message=FALSE, warning=FALSE}
## Procesamiento y armonización de datos clínicos

# Carga de datos
gse17536 <- getGEO("GSE17536", GSEMatrix = TRUE)
exp_matrix17536 <- gse17536[["GSE17536_series_matrix.txt.gz"]]@assayData[["exprs"]]
datos17536 <- gse17536[["GSE17536_series_matrix.txt.gz"]]@phenoData@data

## Filtrado de pacientes
col <- datos17536$`dfs_event (disease free survival; cancer recurrence):ch1`
col[col == "NA"] <- NA
datos17536$DFS_event_raw <- col 
datos17536 <- datos17536[!is.na(datos17536$DFS_event_raw), ]

## Selección de columnas relevantes
datos17536_clean <- data.frame(
  SampleID           = datos17536$geo_accession,
  Age                = as.numeric(datos17536$`age:ch1`),
  Gender             = factor(tolower(datos17536$`gender:ch1`), levels = c("male","female")),
  Stage              = factor(datos17536$`ajcc_stage:ch1`, levels = c("1","2","3","4","UK")),
  Tumor_Location     = factor(rep("UK", nrow(datos17536)), levels = c("distal","proximal","UK")), # no disponible en esta cohorte
  MSI_Status         = factor(rep("UK", nrow(datos17536)), levels = c("MSS","MSI","UK")),        # no disponible
  Treatment_Adjuvant = factor(rep("No", nrow(datos17536)), levels = c("Yes", "No")),
  Treatment_Adjuvant_type = "UK",
  DFS_time           = as.numeric(datos17536$`dfs_time:ch1`),
  DFS_Event          = factor(ifelse(datos17536$`dfs_event (disease free survival; cancer recurrence):ch1`=="no recurrence","No","Yes"),
                              levels = c("Yes","No")),
  OS_time            = as.numeric(datos17536$`overall survival follow-up time:ch1`),
  OS_Event           = factor(ifelse(datos17536$`overall_event (death from any cause):ch1`=="death","Yes","No"),
                              levels = c("Yes","No")),
  Platform           = factor(datos17536$platform_id),
  RNA_Extraction     = factor(datos17536$extract_protocol_ch1),
  Normalization_Method = factor(datos17536$data_processing),
  Cohorte            = "GSE17536",
  Batch              = 2, 
  Percent_Tumor      = ">= 70%",  
  RIN                = ">= 6.5",

stringsAsFactors   = FALSE
)

## Armonización de variables categóricas
datos17536_clean$Gender <- ifelse(datos17536_clean$Gender == "male", "Male",
                           ifelse(datos17536_clean$Gender == "female", "Female", NA))
datos17536_clean$Gender <- factor(datos17536_clean$Gender, levels = c("Male", "Female"))

datos17536_clean$Stage <- dplyr::recode(datos17536_clean$Stage,
  "1" = "I",
  "2" = "II",
  "3" = "III",
  "4" = "IV",
  .default = "UK"
)
datos17536_clean$Stage <- factor(datos17536_clean$Stage, levels = c("I","II","III","IV","UK"))

## Summary
st_options(dfSummary.graph.col = TRUE,  
           dfSummary.graph.magnif = 1.2)
 print(dfSummary(datos17536_clean), method = "render", escape = FALSE)

```


```{r echo=FALSE, message=FALSE, warning=FALSE}
## Matriz de expresión génica ya normalizada proporcionada por el estudio 
exp_matrix17536 <- gse17536[["GSE17536_series_matrix.txt.gz"]]@assayData[["exprs"]]

# Selección de las columnas coincidentes y en el mismo orden que en los datos clínicos ya procesados
exp_matrix17536 <- exp_matrix17536[, datos17536_clean$SampleID]
all(colnames(exp_matrix17536) == datos17536_clean$SampleID)

save(exp_matrix17536, file = "Expresión RMA sin anotar GSE17536.RData")

```


### GSE17537
```{r GSE17537, echo=FALSE, message=FALSE, warning=FALSE}
## Procesamiento y armonización de datos clínicos

# Carga de datos
gse17537 <- getGEO("GSE17537", GSEMatrix = TRUE)
datos17537 <- gse17537[["GSE17537_series_matrix.txt.gz"]]@phenoData@data

## Selección de columnas relevantes
datos17537_clean <- data.frame(
  SampleID           = datos17537$geo_accession,
  Age                = as.numeric(datos17537$`age:ch1`),
  Gender             = factor(tolower(datos17537$`gender:ch1`), levels = c("male","female")),
  Stage              = factor(datos17537$`ajcc_stage:ch1`, levels = c("1","2","3","4","UK")),
  Tumor_Location     = factor(rep("UK", nrow(datos17537)), levels = c("distal","proximal","UK")), # no disponible
  MSI_Status         = factor(rep("UK", nrow(datos17537)), levels = c("MSS","MSI","UK")),        # no disponible
  Treatment_Adjuvant = factor(rep("No", nrow(datos17537)), levels = c("Yes","No","UK")), 
  Treatment_Adjuvant_type = "UK", 
  DFS_time           = as.numeric(datos17537$`dfs_time:ch1`),
  DFS_Event          = factor(ifelse(datos17537$`dfs_event (disease free survival; cancer recurrence):ch1`=="no recurrence","No","Yes"),
                              levels = c("Yes","No")),
  OS_time            = as.numeric(datos17537$`overall survival follow-up time:ch1`),
  OS_Event           = factor(ifelse(datos17537$`overall_event (death from any cause):ch1`=="death","Yes","No"),
                              levels = c("Yes","No")),
  Platform           = factor(datos17537$platform_id),
  RNA_Extraction     = factor(datos17537$extract_protocol_ch1),
  Normalization_Method = factor(datos17537$data_processing),
  Cohorte            = "GSE17537",
  Batch              = 3, 
  Percent_Tumor      = ">= 70%",  
  RIN                = ">= 6.5",
  stringsAsFactors   = FALSE
)

## Armonización de variables categóricas
datos17537_clean$Gender <- ifelse(datos17537_clean$Gender == "male", "Male",
                           ifelse(datos17537_clean$Gender == "female", "Female", NA))
datos17537_clean$Gender <- factor(datos17537_clean$Gender, levels = c("Male", "Female"))

datos17537_clean$Stage <- dplyr::recode(datos17537_clean$Stage,
  "1" = "I",
  "2" = "II",
  "3" = "III",
  "4" = "IV",
  .default = "UK"
)
datos17537_clean$Stage <- factor(datos17537_clean$Stage, levels = c("I","II","III","IV","UK"))

## Summary
st_options(dfSummary.graph.col = TRUE,  
           dfSummary.graph.magnif = 1.2)  
 print(dfSummary(datos17537_clean), method = "render", escape = FALSE)

```

```{r echo=FALSE, message=FALSE, warning=FALSE}
## Matriz de expresión génica ya normalizada proporcionada por el estudio
exp_matrix17537 <- gse17537[["GSE17537_series_matrix.txt.gz"]]@assayData[["exprs"]]

# Selección de las columnas coincidentes y en el mismo orden que en los datos clínicos ya procesados
exp_matrix17537 <- exp_matrix17537[, datos17537_clean$SampleID]
all(colnames(exp_matrix17537) == datos17537_clean$SampleID)

save(exp_matrix17537, file = "Expresión RMA sin anotar GSE17537.RData")
```


### GSE14333
```{r GSE14333, echo=FALSE, warning=FALSE, message=FALSE}
## Procesamiento y armonización de datos clínicos

# Carga de datos
gse14333 <- getGEO("GSE14333", GSEMatrix = TRUE)
datos14333 <- gse14333[["GSE14333_series_matrix.txt.gz"]]@phenoData@data

# Función para extraer valores numéricos o cadenas desde un patrón
extract_field <- function(x, field_name, type="character") {
  pattern <- paste0(field_name, "[:]?\\s*([^;]+)")
  val <- str_match(x, pattern)[,2]
  if(type=="numeric") val <- as.numeric(val)
  return(val)
}

## Selección de columnas relevantes
datos14333_clean <- data.frame(
  SampleID           = datos14333$geo_accession,
  Age                = extract_field(datos14333$`Location:ch1`, "Age_Diag", type="numeric"),
  Gender             = factor(tolower(extract_field(datos14333$`Location:ch1`, "Gender")), levels = c("m","f"), labels = c("Male","Female")),
  Stage              = factor(extract_field(datos14333$`Location:ch1`, "DukesStage"), levels = c("A","B","C","D","UK")),
  Tumor_Location     = factor(extract_field(datos14333$description, "Location"), levels = c("Left","Right","Rectum","UK")),
  MSI_Status         = factor(rep("UK", nrow(datos14333)), levels = c("MSS","MSI","UK")), 
  Treatment_Adjuvant = factor(rep("No", nrow(datos14333)), levels = c("Yes","No","UK")), 
  Treatment_Adjuvant_type = "UK", 
  DFS_time           = as.numeric(extract_field(datos14333$`Location:ch1`, "DFS_Time")),
  DFS_Event          = factor(ifelse(extract_field(datos14333$`Location:ch1`, "DFS_Cens") == "0", "Yes", "No"),
                              levels = c("Yes","No")),
  OS_time            = as.numeric(NA),
  OS_Event           = factor(rep(NA, nrow(datos14333)), levels = c("Yes","No")),
  Platform           = factor(datos14333$platform_id),
  RNA_Extraction     = factor(datos14333$extract_protocol_ch1),
  Normalization_Method = factor(datos14333$data_processing),
  Cohorte            = "GSE14333",
  Batch              = 4, 
  Percent_Tumor      = ">= 70%",  
  RIN                = ">= 6.5",
  stringsAsFactors  = FALSE
)

## Armonización de las variables 
stage_map <- c("A" = "I", "B" = "II", "C" = "III", "D" = "IV", "UK" = NA)
datos14333_clean$Stage <- stage_map[as.character(datos14333_clean$Stage)]
datos14333_clean$Stage <- factor(datos14333_clean$Stage, levels=c("I","II","III","IV","UK"))

tumor_map <- c("Right"="proximal", "Left"="distal", "Rectum"="Rectum")
datos14333_clean$Tumor_Location <- tumor_map[as.character(datos14333_clean$Tumor_Location)]
datos14333_clean$Tumor_Location[is.na(datos14333_clean$Tumor_Location)] <- "UK"
datos14333_clean$Tumor_Location <- factor(datos14333_clean$Tumor_Location, levels=c("distal","proximal","Rectum", "UK"))

## Filtrado de pacientes
datos14333_clean <- datos14333_clean[!is.na(datos14333_clean$DFS_time) & 
                                     !is.na(datos14333_clean$DFS_Event), ]

## Summary
st_options(dfSummary.graph.col = TRUE,  
           dfSummary.graph.magnif = 1.2)  
 print(dfSummary(datos14333_clean), method = "render", escape = FALSE)

 
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
## Matriz de expresión génica ya normalizada proporcionada por el estudio
exp_matrix14333 <- gse14333[["GSE14333_series_matrix.txt.gz"]]@assayData[["exprs"]]

# Selección de las columnas coincidentes y en el mismo orden que en los datos clínicos ya procesados
exp_matrix14333 <- exp_matrix14333[, datos14333_clean$SampleID]
all(colnames(exp_matrix14333) == datos14333_clean$SampleID)

save(exp_matrix14333, file = "Expresión RMA sin anotar GSE14333.RData")

```


### GSE33113
```{r GSE33113, echo=FALSE, message=FALSE, warning=FALSE}
## Procesamiento y armonización de datos clínicos

# Carga de datos
gse33113<- getGEO("GSE33113", GSEMatrix = TRUE)
datos33113 <- gse33113[["GSE33113_series_matrix.txt.gz"]]@phenoData@data

# Eliminación de muestras "normal colon mucosa"
datos33113_limpio <- datos33113 %>%
  filter(`tissue:ch1` != "normal colon mucosa")

## Selcción de varibales de interés
datos33113_clean <- data.frame( 
  SampleID           = datos33113_limpio$geo_accession,
  Age                = as.numeric(gsub(",", ".", datos33113_limpio$`age at diagnosis:ch1`)),
  Gender             = factor(tolower(datos33113_limpio$`Sex:ch1`), 
                              levels = c("m","f"), labels = c("Male","Female")),
  Stage              = factor(sub("AJCC stage ([I|II|III|IV]+).*", "\\1", datos33113_limpio$`disease status:ch1`),
                              levels = c("I","II","III","IV","UK")),
  Tumor_Location     = factor(rep("UK", nrow(datos33113_limpio)), 
                              levels = c("Left","Right","Rectum","UK")),
  MSI_Status         = factor(rep("UK", nrow(datos33113_limpio)), 
                              levels = c("MSS","MSI","UK")),
  Treatment_Adjuvant = factor(rep("No", nrow(datos33113_limpio)), 
                              levels = c("Yes","No","UK")),
  Treatment_Adjuvant_type = factor(rep("UK", nrow(datos33113_limpio)), 
                                   levels = c("5-FU","FOLFOX","UK")),
  DFS_time           = as.numeric(datos33113_limpio$`time to meta or recurrence:ch1`) / 30.44, # meses
  DFS_Event          = factor(ifelse(datos33113_limpio$`meta or recurrence within 3 years:ch1`=="yes","Yes","No"),
                              levels = c("Yes","No")),
  OS_time            = as.numeric(NA),
  OS_Event           = factor(rep(NA, nrow(datos33113_limpio)), levels = c("Yes","No")),
  Platform           = factor(datos33113_limpio$platform_id),
  RNA_Extraction     = factor(datos33113_limpio$extract_protocol_ch1),
  Normalization_Method = factor(datos33113_limpio$data_processing),
  Cohorte            = "GSE33113",
  Batch              = 5, 
  Percent_Tumor      = ">= 70%",  
  RIN                = ">= 7",
  stringsAsFactors   = FALSE
)

## Summary
st_options(dfSummary.graph.col = TRUE,  # Activar gráficos en columnas
           dfSummary.graph.magnif = 1.2)  # Ajustar tamaño de gráficos
 print(dfSummary(datos33113_clean), method = "render", escape = FALSE)
 
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
## Matriz de expresión génica ya normalizada proporcionada por el estudio
exp_matrix33113 <- gse33113[["GSE33113_series_matrix.txt.gz"]]@assayData[["exprs"]]

# Selección de las columnas coincidentes y en el mismo orden que en los datos clínicos ya procesados
exp_matrix33113 <- exp_matrix33113[, datos33113_clean$SampleID]
all(colnames(exp_matrix33113) == datos33113_clean$SampleID)

save(exp_matrix33113, file = "Expresión RMA sin anotar GSE33113.RData")

```


```{r echo=FALSE, message=FALSE, warning=FALSE}
# Antes de unir, hay que estandarizar algunas columnas que difieren entre cohortes

# Columnas numéricas (mantienen NA)
num_cols <- c("Age", "DFS_time", "OS_time", "Batch")
# Columnas categóricas (queremos "UK" si no hay datos)
cat_cols <- c(
  "Gender", "Stage", "Tumor_Location", "MSI_Status",
  "Treatment_Adjuvant", "Treatment_Adjuvant_type",
  "DFS_Event", "OS_Event",
  "Platform", "RNA_Extraction", "Normalization_Method",
  "Cohorte", "Percent_Tumor", "RIN"
)

limpiar_dataset <- function(df) {
  # Convierte N/A o vacíos en NA real
  df[df == "N/A" | df == "" | df == "na" | df == "Na" | df == "NA"] <- NA
  
  # Reemplaza NA por "UK" solo en variables categóricas o de texto
  for (col in cat_cols) {
    if (col %in% names(df)) {
      df[[col]] <- as.character(df[[col]])
      df[[col]][is.na(df[[col]])] <- "UK"
    }
  }
  # Asegura que las numéricas sigan siendo numéricas
  for (col in num_cols) {
    if (col %in% names(df)) {
      df[[col]] <- suppressWarnings(as.numeric(df[[col]]))
    }
  }
  
  return(df)
}
datos39582_clean <- limpiar_dataset(datos39582_clean)
datos17536_clean <- limpiar_dataset(datos17536_clean)
datos17537_clean <- limpiar_dataset(datos17537_clean)
datos14333_clean <- limpiar_dataset(datos14333_clean)
datos33113_clean <- limpiar_dataset(datos33113_clean)



datos39582_clean[] <- lapply(datos39582_clean, function(x) {
  if (is.character(x)) toupper(x) else x
})
datos17536_clean[] <- lapply(datos17536_clean, function(x) {
  if (is.character(x)) toupper(x) else x
})
datos17537_clean[] <- lapply(datos17537_clean, function(x) {
  if (is.character(x)) toupper(x) else x
})
datos14333_clean[] <- lapply(datos14333_clean, function(x) {
  if (is.character(x)) toupper(x) else x
})


save(datos33113_clean, file = "Datos clínicos y técnicos GSE33113.RData")
save(datos14333_clean, file = "Datos clínicos y técnicos GSE14333.RData")
save(datos17537_clean, file = "Datos clínicos y técnicos GSE17537.RData")
save(datos17536_clean, file = "Datos clínicos y técnicos GSE17536.RData")
save(datos39582_clean, file = "Datos clínicos y técnicos GSE39582.RData")

```

## Integración de datos clínicos 

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Unión de datos clínicos de cohortes  
lista_cohortes <- list(
  datos39582_clean,
  datos17536_clean,
  datos17537_clean,
  datos14333_clean,
  datos33113_clean
)

# Convierte todos los factores a carácter para unir mejor
lista_cohortes <- lapply(lista_cohortes, function(df) {
  df[] <- lapply(df, function(x) {
    if (is.factor(x)) as.character(x) else x
  })
  return(df)
})

## Unión
datos_total <- bind_rows(lista_cohortes)

# Estandarizar Gender
datos_total$Gender <- toupper(datos_total$Gender)  # todo en mayúsculas
datos_total$Gender <- factor(datos_total$Gender, levels = c("MALE", "FEMALE"))

# Estandarizar Treatment_Adjuvant
datos_total$Treatment_Adjuvant <- toupper(datos_total$Treatment_Adjuvant)
# Establecemos niveles posibles
datos_total$Treatment_Adjuvant <- factor(datos_total$Treatment_Adjuvant, levels = c("YES", "NO", "UK"))

# Estandarizar DFS_Event
datos_total$DFS_Event <- toupper(datos_total$DFS_Event)
datos_total$DFS_Event <- factor(datos_total$DFS_Event, levels = c("YES", "NO"))

# Estandarizar OS_Event si hace falta
datos_total$OS_Event <- toupper(datos_total$OS_Event)
datos_total$OS_Event <- factor(datos_total$OS_Event, levels = c("YES", "NO", "UK"))


## Summary
st_options(dfSummary.graph.col = TRUE, 
           dfSummary.graph.magnif = 1.2)  
 print(dfSummary(datos_total), method = "render", escape = FALSE)
 
save(datos_total, file = "Datos clínicos y técnicos COHORTE GLOBAL.RData")
```


```{r}
## Filtrado por stage II 
datos_stageII <- datos_total[datos_total$Stage == "II", ]


st_options(dfSummary.graph.col = TRUE,  
           dfSummary.graph.magnif = 1.2)  
 print(dfSummary(datos_stageII), method = "render", escape = FALSE)


save(datos_stageII, file = "Datos clínicos y técnicos COHORTE GLOBAL STAGE II.RData")
```

## Datos transcriptómicos 

### Normalización mediante RMA

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}

ruta_base <- "C:/Users/mjbel/Desktop/TFM - RProject/data/Archivos CEL"
# Buscar todos los archivos .CEL.gz dentro de las subcarpetas
cel_files <- list.files(ruta_base, pattern = "[.]CEL.gz$", recursive = TRUE, full.names = TRUE)
length(cel_files)

# Lectura y RMA de archivos CEL juntos
raw_data <- ReadAffy(filenames = cel_files)
eset_rma <- affy::rma(raw_data)
expr_matrix <- exprs(eset_rma)
dim(expr_matrix)

# Limpieza de los nombres de las columnas dejando solo "GSM" y los dígitos siguientes
colnames(expr_matrix) <- gsub("^(GSM[0-9]+).*", "\\1", colnames(expr_matrix))
expr_samples <- colnames(expr_matrix)
clinical_samples <- datos_total$SampleID

# Verificación de las muestras
# Cuántas de la expresión están en los datos clínicos
sum(expr_samples %in% clinical_samples)
# Cuántas de los datos clínicos están en la expresión
sum(clinical_samples %in% expr_samples)
# Muestras que están en expresión pero no en datos clínicos
setdiff(expr_samples, clinical_samples)
# Muestras que están en datos clínicos pero no en expresión
setdiff(clinical_samples, expr_samples)

# Filtrado de las columnas que están en datos_total
expr_matrix_filtrada <- expr_matrix[, colnames(expr_matrix) %in% datos_total$SampleID]
# Reordena las columnas para que sigan el mismo orden que en datos_total
expr_matrix_filtrada <- expr_matrix_filtrada[, match(datos_total$SampleID, colnames(expr_matrix_filtrada))]

all(colnames(expr_matrix_filtrada) == datos_total$SampleID) ## TRUE

save(eset_rma, expr_matrix_filtrada, file = "Expresión RMA sin anotar ni combat Cohorte global.RData")

```

### Corrección de efecto lote 
#### PCA pre-COMBAT

```{r echo=FALSE, message=FALSE, warning=FALSE}
load("C:/Users/mjbel/Desktop/TFM - RProject/data/Expresión RMA sin anotar ni combat Cohorte global.RData")
load("C:/Users/mjbel/Desktop/TFM - RProject/data/Datos clínicos y técnicos COHORTE GLOBAL.RData")

# Transposición de la matriz de expresión (genes en columnas, muestras en filas)
expr_t <- t(expr_matrix_filtrada)

# PCA centrado y escalado
pca_res <- prcomp(expr_t, scale. = TRUE, center = TRUE)
# Calculo de la varianza explicada (%)
var_exp <- (pca_res$sdev^2) / sum(pca_res$sdev^2) * 100

# Dataframe para graficar
pca_df <- data.frame(
  PC1 = pca_res$x[, 1],
  PC2 = pca_res$x[, 2],
  Cohorte = datos_total$Cohorte 
)

# Paleta de colores
n_colors <- length(unique(pca_df$Cohorte))
colors <- brewer.pal(min(n_colors, 8), "Set2")  
# Etiquetas de ejes con % de varianza
x_lab <- paste0("PC1 (", round(var_exp[1], 2), "%)")
y_lab <- paste0("PC2 (", round(var_exp[2], 2), "%)")
pca_df$Muestra <- rownames(expr_t)

ggplot(pca_df, aes(x = PC1, y = PC2, color = Cohorte)) + 
  geom_point(size = 3, alpha = 0.5) +
  scale_color_manual(values = colors) +
  labs(
    title = "PCA pre-ComBat",
    subtitle = "Agrupación de muestras por cohorte",
    x = x_lab, y = y_lab, color = "Cohorte") +
  theme_classic(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 15, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 12),
    axis.title = element_text(size = 12),
    axis.text  = element_text(size = 12),
    legend.title = element_text(size = 13, face = "bold"),
    legend.text  = element_text(size = 12)
  )


## Representación para memoria 
p_pre <- ggplot(pca_df, aes(x = PC1, y = PC2, color = Cohorte)) + 
  geom_point(size = 3, alpha = 0.5) +
  scale_color_manual(values = colors) +
  labs(title = "Pre-ComBat",x = x_lab,y = y_lab) +
  theme_classic(base_size = 14) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14,
      margin = margin(6, 6, 6, 6)))

```

#### COMBAT

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Extracción del vector por lotes (cohortes)
batch <- as.factor(datos_total$Batch)

# Aplicación de COMBAT
expr_combat <- ComBat(dat = as.matrix(expr_matrix_filtrada),
                      batch = batch,
                      par.prior = TRUE,
                      prior.plots = FALSE)

save(expr_combat, file = "Expresión Combat sin anotar Cohorte global.RData")
```

#### PCA post-COMBAT

```{r echo=FALSE, message=FALSE, warning=FALSE}
load("C:/Users/mjbel/Desktop/TFM - RProject/data/Expresión Combat sin anotar Cohorte global.RData")

### PCA post-COMBAT
expr_combat_t <- t(expr_combat)
pca_res_combat <- prcomp(expr_combat_t, scale. = TRUE, center = TRUE)

pca_df_combat <- data.frame(
  PC1 = pca_res_combat$x[, 1],
  PC2 = pca_res_combat$x[, 2],
  Cohorte = datos_total$Cohorte
)

n_colors <- length(unique(pca_df_combat$Cohorte))
colors <- brewer.pal(min(n_colors, 8), "Set2")

var_exp_combat <- (pca_res_combat$sdev^2) / sum(pca_res_combat$sdev^2) * 100
x_lab <- paste0("PC1 (", round(var_exp_combat[1], 2), "%)")
y_lab <- paste0("PC2 (", round(var_exp_combat[2], 2), "%)")

ggplot(pca_df_combat, aes(x = PC1, y = PC2, color = Cohorte)) + 
  geom_point(size = 2.5, alpha = 0.5) +  
  scale_color_manual(values = colors) + 
  labs(
    title = "PCA post-COMBAT",
    subtitle = "Agrupación de muestras por cohorte",
    x = x_lab, y = y_lab, color = "Cohorte") +
  theme_minimal(base_size = 14) +  
  theme(
    plot.title = element_text(hjust = 0.5, size = 15, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 12),
    axis.title = element_text(size = 12),
    axis.text  = element_text(size = 12),
    legend.title = element_text(size = 13, face = "bold"),
    legend.text  = element_text(size = 12)
  )

p_post <- ggplot(pca_df_combat, aes(x = PC1, y = PC2, color = Cohorte)) + 
  geom_point(size = 3, alpha = 0.5) +
  scale_color_manual(values = colors) +
  labs(title = "Post-ComBat",x = x_lab,y = y_lab) +
  theme_classic(base_size = 14) +
  theme(plot.title = element_text( hjust = 0.5, face = "bold", size = 14,
      margin = margin(6, 6, 6, 6)))


```

```{r echo=FALSE, message=FALSE, warning=FALSE}
############# Representaciones de PCAs para memoria 
pca_combined <- (p_pre | p_post) +
  plot_layout(guides = "collect") &  
  theme(
    legend.position = "right",
    legend.title = element_text(face = "bold", size = 13),
    legend.text  = element_text(size = 12))

pca_final <- pca_combined +
  plot_annotation(
    title = "Análisis de Componentes Principales (PCA)",
    subtitle = "Efecto de la corrección del efecto lote mediante ComBat",
    theme = theme(
      plot.title = element_text(face = "bold", size = 15, hjust = 0.5, margin = margin(10, 10, 5, 10),
        background = element_rect(fill = "grey95",color = "grey40")),
      plot.subtitle = element_text(size = 13, hjust = 0.5, margin = margin(0, 10, 10, 10))))

pca_final

```


### Anotación de sondas 

```{r eval=FALSE, include=FALSE}
load("C:/Users/mjbel/Desktop/TFM - RProject/data/Expresión Combat sin anotar Cohorte global.RData")
expr_combat_df <- as.data.frame(expr_combat)
expr_combat_df$PROBEID <- rownames(expr_combat_df)
probes <- rownames(expr_combat)

# Obtención del mapeo a SYMBOL, ENTREZID, y ENSEMBL
annot <- AnnotationDbi::select(
  hgu133plus2.db,
  keys = probes,
  columns = c("PROBEID", "ENTREZID", "SYMBOL"),
  keytype = "PROBEID"
)

merged_df <- merge(annot, expr_combat_df, by= "PROBEID", all.x = TRUE)


############################################################################# MAPEAR POR SYMBOL

# Quita los genes gene_assignment que esten vacios (estos corresponden a las sondas controles)
subset_df <- subset(merged_df, SYMBOL != "---")
subset_df$PROBEID <-NULL
  
# Es inevitable que haya para el mismo gen varios transcritos, pero para aplicar el resto de funciones y paquetes los hugo symbols tienen que ser únicos. De esta manera no queda más remedio que eliminar filas. Se va a seleccionar el hugosymbol que tenga más variabilidad entre las muestras, ya que el objetivo de la investigación es la expresión diferencial entre clusters. 
# Para ello hay que calcular la desviación estándar de cada transcrito.
# Se seleccionan las columnas que empiezan por 'GSM' y se excluye 'SYMBOL' y "ENTREZ" ya que no es numérica
numeric_columns <- subset_df[, grepl("^GSM", names(subset_df))]
# Calculo de la desviación estándar por filas
subset_df$std_dev <- apply(numeric_columns, 1, sd)

# Se agrupa por hugo symbols y así se meten los duplicados "en el mismo saco" y se seleccionan los que tengan mayor variabilidad (mayor desviación estándar) 
subset_df_unique <- subset_df %>%
    group_by(SYMBOL) %>%
    filter(std_dev == max(std_dev)) %>%
    ungroup()  # Hay que desagrupar el dataframe!

# Verificación de que no haya duplicados en los hugo y que no se hayan eliminado genes que eran únicos. 
sum(duplicated(subset_df_unique))

exp_HG <- subset_df_unique %>% as.data.frame()
rownames(exp_HG) <- exp_HG$SYMBOL
exp_HG <- exp_HG[, sapply(exp_HG, is.numeric)]
exp_HG$std_dev <- NULL

save(exp_HG, file = "Expresión anotada HG Cohorte global.RData")

############################################################################ MAPEAR POR ENTREZID
# Se hace el mismo procedimiento con los identificadores ENTREZ
subset_df <- subset(merged_df, ENTREZID != "---")
subset_df$PROBEID <-NULL

numeric_columns <- subset_df[, grepl("^GSM", names(subset_df))]
subset_df$std_dev <- apply(numeric_columns, 1, sd)

subset_df_unique <- subset_df %>%
    group_by(ENTREZID) %>%
    filter(std_dev == max(std_dev)) %>%
    ungroup()  
sum(duplicated(subset_df_unique))

expr_gene <- subset_df_unique %>% as.data.frame()

expr_gene <- expr_gene %>% as.data.frame()
rownames(expr_gene) <- expr_gene$ENTREZID
exp_entrez <- expr_gene[, sapply(expr_gene, is.numeric)]
exp_entrez$std_dev  <- NULL

save(exp_entrez, file = "Expresión anotada ENTREZ Cohorte global.RData")

```



```{r eval=FALSE, include=FALSE}
# Con el fin de asegurarnos que en el paso anterior no se han eliminado sondas que son necesarias para los análisis posteriores, comprobamos si los genes necesarios están todos disponibles. Si no es así, se explora que ha ocurrido con ellos y se actúa en consecuencia.

lm22 <- read.table("C:/Users/mjbel/OneDrive/Documentos/MÁSTER BIOINFORMÁTICA Y BIOESTADÍSTICA/TFM/TFM - RProject/data/LM22.txt", header = TRUE, sep = "\t", row.names = 1)

# Se ve cuantos genes necesita CIBESORT que no están presentes en exp_HG.
genes_lm22 <- trimws(rownames(lm22)) 
# Comroobación del dataframe exp_HG
genes_exp_HG <- trimws(rownames(exp_HG))   
genes_faltantes_HG <- setdiff(genes_lm22, genes_exp_HG)
length(genes_faltantes_HG)   #Faltan 29 genes de 547
genes_faltantes_HG

# La mayoría son antiguos nombres que se han mapeado con el nombre actualizado. Solo hayq eu renombrar.
row.names(exp_HG)<-trimws(row.names(exp_HG))
rownames(exp_HG)[rownames(exp_HG) == "RCE1"] <- "C11orf80"
rownames(exp_HG)[rownames(exp_HG) == "ADGRE1"] <- "EMR1"
rownames(exp_HG)[rownames(exp_HG) == "ADGRE2"] <- "EMR2"
rownames(exp_HG)[rownames(exp_HG) == "ADGRE3"] <- "EMR3"
rownames(exp_HG)[rownames(exp_HG) == "FCMR"] <- "FAIM3"
rownames(exp_HG)[rownames(exp_HG) == "KLF3"] <- "FLJ13197"
rownames(exp_HG)[rownames(exp_HG) == "ADGRG3"] <- "GPR97"
rownames(exp_HG)[rownames(exp_HG) == "HMGB3"] <- "HMGB3P30"
rownames(exp_HG)[rownames(exp_HG) == "MACF1"] <- "KIAA0754"
rownames(exp_HG)[rownames(exp_HG) == "SEPT5-GP1BB"] <- "SEPT5"

# Se guarda el dataframe optimizado
save(exp_HG, file= "Exp HG 100% optimizado COHORTE GLOBAL.RData")

```

```{r eval=FALSE, include=FALSE} 
# Se hace lo mismo para los paquetes que usen identificadores ENTREZ
library(CMSclassifier)
genes_cms_rf <- listModelGenes("RF")
genes_unicos_cms_rf <- setdiff(genes_cms_rf, row.names(exp_entrez))
print(genes_unicos_cms_rf)

save(exp_entrez, file = "Exp ENTREZ 100% optimizado COHORTE GLOBAL.RData")

```

```{r eval=FALSE, include=FALSE}
# Filtrado por pacientes con estadio II

exp_entrez_stageII <- exp_entrez[, colnames(exp_entrez) %in% datos_stageII$SampleID]
exp_entrez_stageII  <- exp_entrez_stageII [, match(datos_stageII$SampleID, colnames(exp_entrez_stageII ))]
all(colnames(exp_entrez_stageII ) == datos_stageII$SampleID) # TRUE

save(exp_entrez_stageII , file = "Exp ENTREZ 100% optimizado STAGE II.RData")


exp_HG_stageII <- exp_HG[, colnames(exp_HG) %in% datos_stageII$SampleID]
exp_HG_stageII  <- exp_HG_stageII [, match(datos_stageII$SampleID, colnames(exp_HG_stageII ))]
all(colnames(exp_HG_stageII ) == datos_stageII$SampleID) # TRUE

save(exp_HG_stageII , file = "Exp HG 100% optimizado STAGE II.RData")

```


## DESCRIPTIVA GENERAL STAGE II 

```{r}
load("C:/Users/mjbel/OneDrive/Documentos/MÁSTER BIOINFORMÁTICA Y BIOESTADÍSTICA/TFM/TFM - RProject/data/Datos clínicos y técnicos COHORTE GLOBAL STAGE II.RData")

st_options(dfSummary.graph.col = TRUE,  
           dfSummary.graph.magnif = 1.2)  
 print(dfSummary(datos_stageII_ext), method = "render", escape = FALSE)

load("C:/Users/mjbel/OneDrive/Documentos/MÁSTER BIOINFORMÁTICA Y BIOESTADÍSTICA/TFM/TFM - RProject/data/Exp ENTREZ 100% optimizado STAGE II.RData")
load("C:/Users/mjbel/OneDrive/Documentos/MÁSTER BIOINFORMÁTICA Y BIOESTADÍSTICA/TFM/TFM - RProject/data/Exp HG 100% optimizado STAGE II.RData")

```


```{r}
## HTML con la descriptiva 

st_options(
  dfSummary.graph.col = TRUE,
  dfSummary.graph.magnif = 1.2
)

cohortes <- unique(datos_stageII_ext$Cohorte)
cohortes

for (c in cohortes) {
  
  datos_cohorte <- datos_stageII_ext %>%
    filter(Cohorte == c)
  
  df_sum <- dfSummary(datos_cohorte, escape = FALSE)
  
  view(
    df_sum,
    file = paste0("dfSummary_", c, ".html")
  )
}

```




